/*康托展开的运算 X=a[n](n-1)!+a[n-1](n-2)!+…+a[i]*(i-1)!+…+a[1]*0!, 其中 a[i]为整数，
并且0 <= a[i] <= i, 0 <= i < n, 表示当前未出现的的元素中排第几个。
直观起见，我们举例[2, 3, 4, 1]来说明康托展开的运作步骤：
命所求字典序为 rank=0
1.第1位是2，那么以1打头的所有全排列一定排在这个全排列之前，那么以1打头的全排列有 (3!) = 6种，rank=rank+1∗3!=6
2.第2位是3，那么以1与2作为第二位的所有全排列一定在这个圈排列之前。不过我们已经让 2 打头了，因此不
需要再考虑2占第二位的情况，只需要计算1占第二位的情况。rank=rank+1∗2!=8
3.第三位是4，同时，我们计算以1占第三位的所有情况。rank=rank+1∗1!=9
4.最后一位，是不需要判定的，因为前n−1位给定后，第n位自定。当然，为了也适应前面推导，可以记 rank=rank+0∗0!=9。
由是，排在 [2, 3, 4, 1] 之前的全排列共有9个，那么 [2, 3, 4, 1] 应当是第10个全排列。*/
#include<stdio.h>
#define Max 100

int fun(int num)//求阶乘
{
	if(num<=1)
		return 1;
	else
		return(fun(num-1)*num);
}

int main()
{
	int num[Max];//存放比当前元素小的数的个数
	char s[Max];//存放我们要找的那个数
	int i=0,j=0,k=0,count=0,sum=0;
	char val;
	
	while(scanf("%c",&val))//获取元素
	{
		if(val=='\n')
			break;
		else
		{
			s[count]=val;
			count++;	
		}
	}
	
//分别求得元素的排序，如第一个元素需要和剩下的n-1个比较，第二个需要和剩下的n-2个比较……
	for(i=0;i<count;i++)
	{
		for(j=i+1;j<count;j++)
		{
			if(s[i]>s[j])
				k++;
		}
		num[i]=k;//有几个数比当前元素小 
		k=0;
	}


for(j=count-1;j>=0;j--)//输出结果
{
	sum+=num[k]*fun(j);
	k++;
}
printf("该数字位置为%d\n",sum+1);

return 0; 
		
} 
